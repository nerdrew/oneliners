#!/usr/bin/env bash

set -eu -o pipefail

usage() {
  cat <<EOF
Usage: git fresh [--force] [--rebase-abort] [BRANCH=origin/HEAD]

Fetch the target BRANCH, stash changes if necessary, and rebase on it.  If the
current branch matches \$GIT_PURGE_KEEP_BRANCHES, the don't rebase, only pull.
Prune merged branches after.
EOF

  exit "$1"
}

main() {
  local remote current keep_branches stashed force unpushed_changes rebase_abort remote_branch
  local -a purge_keep_branches

  while (( $# )); do
    if [[ -z "$1" ]]; then
      break
    elif [[ "$1" == "-h" || "$1" == "--help" ]]; then
      usage 0
    elif [[ "$1" == "-f" || "$1" == "--force" ]]; then
      force=1
    elif [[ "$1" == "--rebase-abort" ]]; then
      rebase_abort=1
    elif [[ "$1" == "--debug" ]]; then
      set -x
    elif [[ "${1:0:1}" == "-" ]]; then
      echo "Unknown flag: ${1}" 1>&2
      usage 1
    elif [[ -z "${remote:-}" ]]; then
      remote=$1
    elif [[ -z "${remote_branch:-}" ]]; then
      remote_branch=$1
    else
      echo "Unknown argument: ${1}" 1>&2
      usage 1
    fi

    shift
  done

  current=$(git rev-parse --abbrev-ref --verify HEAD)
  read -r -a purge_keep_branches <<< "main master ${GIT_PURGE_KEEP_BRANCHES[*]:-}"
  keep_branches="$(printf "|%s" "${purge_keep_branches[@]}")"

  if ! git config "branch.$current.remote" > /dev/null; then
    echo "Setting upstream branch: git branch --set-upstream-to=origin/$current" 1>&2
    git branch --set-upstream-to="origin/$current" || true
  fi

  if [[ -z "${remote:-}" ]]; then
    if ! git rev-parse --verify --abbrev-ref --symbolic-full-name origin/HEAD &>/dev/null; then
      git remote set-head origin -a
    fi
    remote=$(git rev-parse --verify --abbrev-ref --symbolic-full-name origin/HEAD)
  fi

  if [[ -z "${remote_branch:-}" ]]; then
    if [[ "${remote}" =~ "/" ]]; then
      remote_branch=${remote#*/}
      remote=${remote%%/*}
    else
      if ! git rev-parse --verify --abbrev-ref --symbolic-full-name "${remote}" &>/dev/null; then
        git remote set-head "${remote}" -a
      fi
      remote_branch=$(git rev-parse --verify --abbrev-ref --symbolic-full-name "${remote}")
      remote_branch=${remote_branch#*/}
    fi
  fi

  if ! git diff --quiet --ignore-submodules=dirty "origin/${current}"; then
    unpushed_changes=1
  fi

  if [[ "$remote" != origin ]]; then
    git fetch --recurse-submodules --prune "${remote}"
  fi

  if ! git pull --prune --recurse-submodules --ff-only origin "${current}"; then
    if [[ "${unpushed_changes:-}" == 1 ]]; then
      echo "Pull failed and there are local changes, exiting" 1>&2
      exit 1
    else
      echo "git pull --prune --recurse-submodules --ff-only failed but there are no unpushed changes, will git reset --hard ${remote}/${remote_branch}" 1>&2
      echo "The sha before resetting=${current}" 1>&2
      git reset --hard "origin/${current}"
    fi
  fi

  # #| removes the leading "|"
  if [[ "${force:-}" == "1" ]] || grep -qviE "${keep_branches#|}" <<< "$current" ; then
    if ! git diff --quiet --ignore-submodules=dirty "$(git merge-base HEAD "${remote}/${remote_branch}")..${remote}/${remote_branch}"; then
      if ! git diff --quiet --ignore-submodules=dirty; then
        stashed=1
        git stash
      fi

      if ! git rebase "${remote}" && [[ "${rebase_abort}" == 1 ]]; then
        echo "Rebase failed, git rebase --abort -ing" 1>&2
        git rebase --abort
      elif [[ "${stashed:-}" == "1" ]]; then
        echo "Rebase failed, exiting, NOTE: CHANGES LEFT STASHED" 1>&2
        exit 1
      else
        echo "Rebase failed, exiting" 1>&2
        exit 1
      fi

      if [[ "${stashed:-}" == "1" ]]; then
        git stash pop
      fi
    fi
  else
    echo "Skipping rebase of $current since it is blacklisted in GIT_PURGE_KEEP_BRANCHES='${purge_keep_branches[*]}'" 1>&2
  fi

  if [[ "$current" == "$remote_branch" ]]; then
    git-purge-merged-branches || echo "Failed to delete some merged branches, continuing."
  fi
}

main "$@"
